<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CMYK Network MultiTouch</title>
<style>
html,body{
    margin:0;
    padding:0;
    overflow:hidden;
    background:#f4f4f4;
    touch-action:none;
}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener("resize", ()=>{
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

const activePointers = new Map();

canvas.addEventListener("pointerdown", e=>{
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
});

canvas.addEventListener("pointermove", e=>{
    if(activePointers.has(e.pointerId)){
        activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    }
});

canvas.addEventListener("pointerup", e=>{
    activePointers.delete(e.pointerId);
});
canvas.addEventListener("pointercancel", e=>{
    activePointers.delete(e.pointerId);
});

const palettes = [
    ["#00FFFF","#FF00FF","#FFFF00","#000000"],
    ["#00BFFF","#FF1493","#FFD700","#111111"],
    ["#40E0D0","#FF00AA","#FFEA00","#000000"]
];

let currentPalette = 0;

canvas.addEventListener("click", ()=>{
    currentPalette = (currentPalette + 1) % palettes.length;
});

class Node{
    constructor(x,y,r){
        this.baseX = x;
        this.baseY = y;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.r = r;
        this.mass = r * 0.6;
        this.colorIndex = Math.floor(Math.random()*4);
    }

    applyForce(fx, fy){
        this.vx += fx / this.mass;
        this.vy += fy / this.mass;
    }

    update(){
        // spring to base
        let spring = 0.02;
        this.applyForce((this.baseX - this.x)*spring,
                        (this.baseY - this.y)*spring);

        // repulsion from all active touches
        activePointers.forEach(pointer=>{
            let dx = this.x - pointer.x;
            let dy = this.y - pointer.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            let repelRadius = 180;

            if(dist < repelRadius){
                let force = (repelRadius - dist)/repelRadius;
                let strength = 4.5;
                this.applyForce((dx/dist)*force*strength,
                                (dy/dist)*force*strength);
            }
        });

        // friction
        this.vx *= 0.93;
        this.vy *= 0.93;

        this.x += this.vx;
        this.y += this.vy;
    }

    draw(){
        const colors = palettes[currentPalette];

        ctx.beginPath();
        ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
        ctx.fillStyle = colors[this.colorIndex];
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.x,this.y,this.r*0.5,0,Math.PI*2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
    }
}

let nodes = [];

function generate(){
    nodes = [];
    const count = 220;
    const cx = canvas.width/2;
    const cy = canvas.height/2;

    for(let i=0;i<count;i++){
        let angle = Math.random()*Math.PI*2;
        let radius = Math.random()*canvas.height*0.35;
        let x = cx + Math.cos(angle)*radius + (Math.random()-0.5)*150;
        let y = cy + Math.sin(angle)*radius + (Math.random()-0.5)*150;
        let r = Math.random()*6+3;

        nodes.push(new Node(x,y,r));
    }
}

generate();

function connectNodes(){
    const colors = palettes[currentPalette];

    for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
            let dx = nodes[i].x - nodes[j].x;
            let dy = nodes[i].y - nodes[j].y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if(dist < 100){
                ctx.beginPath();
                ctx.moveTo(nodes[i].x,nodes[i].y);
                ctx.lineTo(nodes[j].x,nodes[j].y);

                ctx.strokeStyle =
                  colors[(nodes[i].colorIndex + nodes[j].colorIndex) % 4];

                ctx.globalAlpha = 0.2;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
    }
}

function animate(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    nodes.forEach(n=>n.update());
    connectNodes();
    nodes.forEach(n=>n.draw());

    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
