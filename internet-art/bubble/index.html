<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CMYK Acid Network</title>
<style>
html,body{
    margin:0;
    padding:0;
    overflow:hidden;
    background:#f4f4f4;
    touch-action:none;
}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener("resize", ()=>{
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

const activePointers = new Map();

// ---------------- AUDIO ENGINE ----------------
let audioCtx, osc, filter, gainNode, lfo, lfoGain;

function initAudio(){
    if(audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    osc = audioCtx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.value = 120;

    filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 500;
    filter.Q.value = 14;

    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.18;

    lfo = audioCtx.createOscillator();
    lfo.frequency.value = 2;

    lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 300;

    lfo.connect(lfoGain);
    lfoGain.connect(filter.frequency);

    osc.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    osc.start();
    lfo.start();
}

// pointer events
canvas.addEventListener("pointerdown", e=>{
    initAudio();
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
});
canvas.addEventListener("pointermove", e=>{
    if(activePointers.has(e.pointerId)){
        activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    }
});
canvas.addEventListener("pointerup", e=>{
    activePointers.delete(e.pointerId);
});
canvas.addEventListener("pointercancel", e=>{
    activePointers.delete(e.pointerId);
});

const palettes = [
    ["#00FFFF","#FF00FF","#FFFF00","#000000"]
];

class Node{
    constructor(x,y,r){
        this.baseX = x;
        this.baseY = y;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.r = r;
        this.mass = r * 0.4;
        this.colorIndex = Math.floor(Math.random()*4);
        this.offset = Math.random()*1000;
    }

    applyForce(fx, fy){
        this.vx += fx / this.mass;
        this.vy += fy / this.mass;
    }

    update(time){

        // ---- ORGANIC DRIFT ----
        let driftX = Math.sin(time*0.001 + this.offset)*0.8;
        let driftY = Math.cos(time*0.0012 + this.offset)*0.8;
        this.applyForce(driftX, driftY);

        // ---- SPRING BACK ----
        let spring = 0.01;
        this.applyForce((this.baseX - this.x)*spring,
                        (this.baseY - this.y)*spring);

        // ---- REPULSION ----
        activePointers.forEach(pointer=>{
            let dx = this.x - pointer.x;
            let dy = this.y - pointer.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let repelRadius = 200;

            if(dist < repelRadius){
                let force = (repelRadius - dist)/repelRadius;
                let strength = 6;
                this.applyForce((dx/dist)*force*strength,
                                (dy/dist)*force*strength);
            }
        });

        // friction
        this.vx *= 0.95;
        this.vy *= 0.95;

        this.x += this.vx;
        this.y += this.vy;
    }

    draw(){
        const colors = palettes[0];

        ctx.beginPath();
        ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
        ctx.fillStyle = colors[this.colorIndex];
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.x,this.y,this.r*0.5,0,Math.PI*2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
    }
}

let nodes=[];

function generate(){
    nodes=[];
    const count=180; // sedikit lebih jarang biar bubble lebih besar
    const cx=canvas.width/2;
    const cy=canvas.height/2;

    for(let i=0;i<count;i++){
        let angle=Math.random()*Math.PI*2;
        let radius=Math.random()*canvas.height*0.4;
        let x=cx+Math.cos(angle)*radius+(Math.random()-0.5)*200;
        let y=cy+Math.sin(angle)*radius+(Math.random()-0.5)*200;
        let r=Math.random()*12+8; // BUBBLE LEBIH BESAR

        nodes.push(new Node(x,y,r));
    }
}

generate();

function connectNodes(){
    const colors = palettes[0];

    for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
            let dx=nodes[i].x-nodes[j].x;
            let dy=nodes[i].y-nodes[j].y;
            let dist=Math.sqrt(dx*dx+dy*dy);

            if(dist<130){
                ctx.beginPath();
                ctx.moveTo(nodes[i].x,nodes[i].y);
                ctx.lineTo(nodes[j].x,nodes[j].y);
                ctx.strokeStyle = colors[
                    (nodes[i].colorIndex+nodes[j].colorIndex)%4
                ];
                ctx.globalAlpha=0.25;
                ctx.stroke();
                ctx.globalAlpha=1;
            }
        }
    }
}

function updateAudio(){
    if(!audioCtx) return;

    let pointerCount = activePointers.size;

    let cutoff = 500 + pointerCount*700;
    filter.frequency.setTargetAtTime(cutoff,
        audioCtx.currentTime,0.1);

    filter.Q.setTargetAtTime(14 + pointerCount*5,
        audioCtx.currentTime,0.1);

    osc.frequency.setTargetAtTime(
        120 + pointerCount*20,
        audioCtx.currentTime,0.2);
}

function animate(time){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    nodes.forEach(n=>n.update(time));
    connectNodes();
    nodes.forEach(n=>n.draw());
    updateAudio();

    requestAnimationFrame(animate);
}

animate(0);
</script>
</body>
</html>
